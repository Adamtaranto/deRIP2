{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<pre><code>\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u255d\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre> <p>deRIP2 scans aligned sequences for evidence of un-RIP'd precursor states, allowing for improved RIP-correction across large repeat families in which members are independently RIP'd.</p> <p>Use deRIP2 to:</p> <ul> <li> <p>Predict ancestral fungal transposon sequences by correcting for RIP-like mutations (CpA --&gt; TpA) and cytosine deamination (C --&gt; T) events.</p> </li> <li> <p>Mask RIP or deamination events as ambiguous bases to remove RIP signal from phylogenetic analyses.</p> </li> </ul>"},{"location":"#table-of-contents","title":"Table of contents","text":"<ul> <li>Installation</li> <li>Algorithm overview</li> <li>Report Issues</li> <li>License</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install from PyPi.</p> <pre><code>pip install derip2\n</code></pre> <p>Pip install latest development version from GitHub.</p> <pre><code>pip install git+https://github.com/Adamtaranto/deRIP2.git\n</code></pre> <p>Test installation.</p> <pre><code># Print version number and exit.\nderip2 --version\n\n# Get usage information\nderip2 --help\n</code></pre>"},{"location":"#setup-development-environment","title":"Setup Development Environment","text":"<p>If you want to contribute to the project or run the latest development version, you can clone the repository and install the package in editable mode.</p> <pre><code># Clone repository\ngit clone https://github.com/Adamtaranto/deRIP2.git &amp;&amp; cd deRIP2\n\n# Create virtual environment\nconda env create -f environment.yml\n\n# Activate environment\nconda activate derip2-dev\n\n# Install package in editable mode\npip install -e '.[dev]'\n</code></pre>"},{"location":"#algorithm-overview","title":"Algorithm overview","text":"<p>For each column in input alignment:</p> <ul> <li>Check if number of gapped rows is greater than max gap proportion. If true, then a gap is added to the output sequence.</li> <li>Set invariant column values in output sequence.</li> <li>If at least X proportion of bases are C/T or G/A (i.e. <code>max-snp-noise</code> = 0.4, then at least 0.6 of positions in column must be C/T or G/A).</li> <li>If reaminate option is set then revert T--&gt;C or A--&gt;G.</li> <li>If reaminate is not set then check for number of positions in RIP dinucleotide context (C/TpA or TpG/A).</li> <li>If proportion of positions in column in RIP-like context =&gt; <code>min-rip-like</code> threshold, AND at least one substrate and one product motif (i.e. CpA and TpA) is present, perform RIP correction in output sequence.</li> <li>For all remaining positions in output sequence (not filled by gap, reaminate, or RIP-correction) inherit sequence from input sequence with the fewest observed RIP events (or greatest GC content if RIP is not detected or multiple sequences sharing min-RIP count).</li> </ul>"},{"location":"#issues","title":"Issues","text":"<p>Submit feedback and questions in the discussion forum</p>"},{"location":"#license","title":"License","text":"<p>Software provided under MIT license.</p>"},{"location":"tutorial/","title":"Getting Started","text":"In\u00a0[\u00a0]: Copied! <pre># Uncomment to install\n# !pip install derip2\n\n# For the latest development version\n# !pip install git+https://github.com/Adamtaranto/deRIP2.git\n</pre> # Uncomment to install # !pip install derip2  # For the latest development version # !pip install git+https://github.com/Adamtaranto/deRIP2.git In\u00a0[\u00a0]: Copied! <pre>%matplotlib inline\nimport os\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nfrom IPython.display import Image, display\n\n# Import the DeRIP class\nfrom derip2.derip import DeRIP\n\n\n# Create output directory if it doesn't exist\noutput_dir = 'output'\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n</pre> %matplotlib inline import os  import matplotlib.pyplot as plt import seaborn as sns import pandas as pd from IPython.display import Image, display  # Import the DeRIP class from derip2.derip import DeRIP   # Create output directory if it doesn't exist output_dir = 'output' if not os.path.exists(output_dir):     os.makedirs(output_dir) In\u00a0[\u00a0]: Copied! <pre># If running this notebook on Google Colab, download the example alignment file\nif 'google.colab' in str(get_ipython()):\n    !wget -O mintest.fa https://raw.githubusercontent.com/Adamtaranto/deRIP2/main/tests/data/mintest.fa\n    # Set the path to the alignment file\n    alignment_file = 'mintest.fa'\nelse:\n    # Set the path to the alignment file\n    alignment_file = '../tests/data/mintest.fa'\n</pre> # If running this notebook on Google Colab, download the example alignment file if 'google.colab' in str(get_ipython()):     !wget -O mintest.fa https://raw.githubusercontent.com/Adamtaranto/deRIP2/main/tests/data/mintest.fa     # Set the path to the alignment file     alignment_file = 'mintest.fa' else:     # Set the path to the alignment file     alignment_file = '../tests/data/mintest.fa' In\u00a0[\u00a0]: Copied! <pre># Create a DeRIP object by loading the alignment\nderip_obj = DeRIP(\n    alignment_file,\n    max_snp_noise=0.2,  # Maximum proportion of conflicting SNPs permitted\n    min_rip_like=0.5,  # Minimum proportion of deamination events in RIP context\n    max_gaps=0.7,  # Maximum proportion of gaps in a column)\n    reaminate=False,  # Don't correct all deamination events\n)\n# Print basic information about the alignment\nprint(derip_obj)\n</pre> # Create a DeRIP object by loading the alignment derip_obj = DeRIP(     alignment_file,     max_snp_noise=0.2,  # Maximum proportion of conflicting SNPs permitted     min_rip_like=0.5,  # Minimum proportion of deamination events in RIP context     max_gaps=0.7,  # Maximum proportion of gaps in a column)     reaminate=False,  # Don't correct all deamination events ) # Print basic information about the alignment print(derip_obj) In\u00a0[\u00a0]: Copied! <pre># Perform RIP correction\nderip_obj.calculate_rip(label='deRIP_mintest')\n\n# Access corrected positions\nprint(f'\\nDeRIP2 found {len(derip_obj.corrected_positions)} columns to repair.')\n\n# Print a summary of RIP mutations\nrip_summary = derip_obj.rip_summary()\nprint('\\nRIP Mutation Summary:')\nprint(rip_summary)\n\n# Print colourized alignment + consensus\nprint('\\nPrint function now returns colourized alignment + consensus:')\nprint(f'{derip_obj}')\n# Target bases are bolded, substrate dinucleotides are blue, product dinucleotides are red\n# Corrected positions in the consensus are highlighted in green\n</pre> # Perform RIP correction derip_obj.calculate_rip(label='deRIP_mintest')  # Access corrected positions print(f'\\nDeRIP2 found {len(derip_obj.corrected_positions)} columns to repair.')  # Print a summary of RIP mutations rip_summary = derip_obj.rip_summary() print('\\nRIP Mutation Summary:') print(rip_summary)  # Print colourized alignment + consensus print('\\nPrint function now returns colourized alignment + consensus:') print(f'{derip_obj}') # Target bases are bolded, substrate dinucleotides are blue, product dinucleotides are red # Corrected positions in the consensus are highlighted in green In\u00a0[\u00a0]: Copied! <pre># Get the corrected consensus sequence\nconsensus_seq = derip_obj.get_consensus_string()\nprint(f'Consensus sequence length: {len(consensus_seq)} bp')\nprint(f'First 100 bp: {consensus_seq[:100]}')\n\n# Write the consensus sequence to a file\nconsensus_file = os.path.join(output_dir, 'consensus.fasta')\n\nprint(f'\\nWriting consensus sequence to: {consensus_file}')\n\nderip_obj.write_consensus(consensus_file, consensus_id='deRIP_mintest')\n</pre> # Get the corrected consensus sequence consensus_seq = derip_obj.get_consensus_string() print(f'Consensus sequence length: {len(consensus_seq)} bp') print(f'First 100 bp: {consensus_seq[:100]}')  # Write the consensus sequence to a file consensus_file = os.path.join(output_dir, 'consensus.fasta')  print(f'\\nWriting consensus sequence to: {consensus_file}')  derip_obj.write_consensus(consensus_file, consensus_id='deRIP_mintest') In\u00a0[\u00a0]: Copied! <pre># Write the alignment with the consensus sequence appended\nout_alignment_file = os.path.join(output_dir, 'alignment_with_consensus.fasta')\n\nprint(f'Writing alignment with consensus to: {out_alignment_file}')\n\nderip_obj.write_alignment(\n    out_alignment_file,\n    append_consensus=True,  # Append the consensus sequence to the alignment\n    mask_rip=True,  # Mask RIP positions in the output alignment\n    consensus_id='deRIP_mintest',\n)\n</pre> # Write the alignment with the consensus sequence appended out_alignment_file = os.path.join(output_dir, 'alignment_with_consensus.fasta')  print(f'Writing alignment with consensus to: {out_alignment_file}')  derip_obj.write_alignment(     out_alignment_file,     append_consensus=True,  # Append the consensus sequence to the alignment     mask_rip=True,  # Mask RIP positions in the output alignment     consensus_id='deRIP_mintest', ) <p>In the above example we used <code>mask_rip=True</code> to mask RIP events as ambiguous bases in the output alignment. If you want to keep the original sequences intact and only append the consensus sequence, you can set <code>mask_rip=False</code>.</p> <p>You can preview the masked alignment using the <code>print_alignment()</code> method.b</p> In\u00a0[\u00a0]: Copied! <pre># Print masked alignment\nprint(f'Mutation masked alignment:\\n{derip_obj.colored_masked_alignment}')\n# Note: Consensus is not part of the masked alignment\nprint(f'{derip_obj.colored_consensus} {\"deRIP_mintest\"}\\n')\n</pre> # Print masked alignment print(f'Mutation masked alignment:\\n{derip_obj.colored_masked_alignment}') # Note: Consensus is not part of the masked alignment print(f'{derip_obj.colored_consensus} {\"deRIP_mintest\"}\\n') In\u00a0[\u00a0]: Copied! <pre># Calculate CRI for all sequences in the alignment\nderip_obj.calculate_cri_for_all()\n\n# Get a summary table of CRI values\ncri_summary = derip_obj.summarize_cri()\nprint(f'\\nCRI Summary Table:\\n{cri_summary}')\n</pre> # Calculate CRI for all sequences in the alignment derip_obj.calculate_cri_for_all()  # Get a summary table of CRI values cri_summary = derip_obj.summarize_cri() print(f'\\nCRI Summary Table:\\n{cri_summary}') In\u00a0[\u00a0]: Copied! <pre># Sort alignment by CRI values (descending order)\nsorted_alignment = derip_obj.sort_by_cri(descending=True)\n\n# Print sequences in order of descending CRI\nprint('Sequences sorted by CRI (lowest to highest):')\nfor i, record in enumerate(sorted_alignment):\n    print(f'{i + 1}. {record.id}: CRI={record.annotations[\"CRI\"]:.4f}')\n</pre> # Sort alignment by CRI values (descending order) sorted_alignment = derip_obj.sort_by_cri(descending=True)  # Print sequences in order of descending CRI print('Sequences sorted by CRI (lowest to highest):') for i, record in enumerate(sorted_alignment):     print(f'{i + 1}. {record.id}: CRI={record.annotations[\"CRI\"]:.4f}') In\u00a0[\u00a0]: Copied! <pre># Filter alignment to keep only sequences with CRI above a threshold\nmin_cri_threshold = -1.6\n\n# Return a new alignment object with sequences that meet the criteria\n# Set inplace=True to filter the original alignment object\nfiltered_alignment = derip_obj.filter_by_cri(min_cri=min_cri_threshold, inplace=False)\n\n# Print the number of sequences that remain after filtering\nprint(\n    f'After filtering (CRI &gt;= {min_cri_threshold}): {len(filtered_alignment)} sequences remain'\n)\n\n# Print remaining records in the filtered alignment\nfor record in filtered_alignment:\n    print(f'{record.id}: CRI={record.annotations[\"CRI\"]:.4f}')\n</pre> # Filter alignment to keep only sequences with CRI above a threshold min_cri_threshold = -1.6  # Return a new alignment object with sequences that meet the criteria # Set inplace=True to filter the original alignment object filtered_alignment = derip_obj.filter_by_cri(min_cri=min_cri_threshold, inplace=False)  # Print the number of sequences that remain after filtering print(     f'After filtering (CRI &gt;= {min_cri_threshold}): {len(filtered_alignment)} sequences remain' )  # Print remaining records in the filtered alignment for record in filtered_alignment:     print(f'{record.id}: CRI={record.annotations[\"CRI\"]:.4f}') <p>Instead of setting a threshold, you can also specify the number of sequences to keep using the <code>keep_low_cri()</code> method. This will keep the specified number of sequences with the lowest CRI values.</p> In\u00a0[\u00a0]: Copied! <pre># Keep only the top 3 sequences with the lowest CRI values\n# By default, keep_low_cri() will return a new alignment object\n# Set inplace=True to filter the original alignment object\nthree_lowest_cri_align = derip_obj.keep_low_cri(n=3, inplace=False)\n\n# Print the number of sequences that remain after filtering\nprint(\n    f'After keeping the 3 sequences with the lowest CRI values: {len(three_lowest_cri_align)} sequences remain'\n)\n\n# Print remaining records in the filtered alignment\nprint(three_lowest_cri_align)\n</pre> # Keep only the top 3 sequences with the lowest CRI values # By default, keep_low_cri() will return a new alignment object # Set inplace=True to filter the original alignment object three_lowest_cri_align = derip_obj.keep_low_cri(n=3, inplace=False)  # Print the number of sequences that remain after filtering print(     f'After keeping the 3 sequences with the lowest CRI values: {len(three_lowest_cri_align)} sequences remain' )  # Print remaining records in the filtered alignment print(three_lowest_cri_align) In\u00a0[\u00a0]: Copied! <pre># Calculate GC content for all sequences\ngc_values = derip_obj.get_gc_content()\n\n# Print summary of GC content statistics\ngc_content_values = [item['GC_content'] for item in gc_values]\nprint('GC Content Summary:')\nprint(f'  Min: {min(gc_content_values):.4f} ({min(gc_content_values) * 100:.2f}%)')\nprint(f'  Max: {max(gc_content_values):.4f} ({max(gc_content_values) * 100:.2f}%)')\nprint(\n    f'  Mean: {sum(gc_content_values) / len(gc_content_values):.4f} ({sum(gc_content_values) / len(gc_content_values) * 100:.2f}%)'\n)\n\n# Create DataFrame from gc_values\ngc_df = pd.DataFrame(gc_values)\n\n# Create histogram using seaborn\nplt.figure(figsize=(10, 6))\nsns.histplot(data=gc_df, x='GC_content', kde=True, bins=10)\nplt.title('Distribution of GC Content Across Sequences')\nplt.xlabel('GC Content')\nplt.ylabel('Frequency')\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.savefig(os.path.join(output_dir, 'gc_content_histogram.png'), dpi=300)\nplt.show()\n</pre> # Calculate GC content for all sequences gc_values = derip_obj.get_gc_content()  # Print summary of GC content statistics gc_content_values = [item['GC_content'] for item in gc_values] print('GC Content Summary:') print(f'  Min: {min(gc_content_values):.4f} ({min(gc_content_values) * 100:.2f}%)') print(f'  Max: {max(gc_content_values):.4f} ({max(gc_content_values) * 100:.2f}%)') print(     f'  Mean: {sum(gc_content_values) / len(gc_content_values):.4f} ({sum(gc_content_values) / len(gc_content_values) * 100:.2f}%)' )  # Create DataFrame from gc_values gc_df = pd.DataFrame(gc_values)  # Create histogram using seaborn plt.figure(figsize=(10, 6)) sns.histplot(data=gc_df, x='GC_content', kde=True, bins=10) plt.title('Distribution of GC Content Across Sequences') plt.xlabel('GC Content') plt.ylabel('Frequency') plt.grid(alpha=0.3) plt.tight_layout() plt.savefig(os.path.join(output_dir, 'gc_content_histogram.png'), dpi=300) plt.show() In\u00a0[\u00a0]: Copied! <pre># Filter alignment to keep only sequences with GC content above a threshold\nmin_gc_threshold = 0.4\nfiltered_by_gc = derip_obj.filter_by_gc(min_gc=min_gc_threshold, inplace=False)\n\nprint(\n    f'After filtering (GC &gt;= {min_gc_threshold}): {len(filtered_by_gc)} sequences remain'\n)\nfor record in filtered_by_gc:\n    print(f'{record.id}: GC={record.annotations[\"GC_content\"]:.4f}')\n</pre> # Filter alignment to keep only sequences with GC content above a threshold min_gc_threshold = 0.4 filtered_by_gc = derip_obj.filter_by_gc(min_gc=min_gc_threshold, inplace=False)  print(     f'After filtering (GC &gt;= {min_gc_threshold}): {len(filtered_by_gc)} sequences remain' ) for record in filtered_by_gc:     print(f'{record.id}: GC={record.annotations[\"GC_content\"]:.4f}') <p>We can retain just the n records with the highest GC using the <code>keep_high_gc()</code> method.</p> In\u00a0[\u00a0]: Copied! <pre># Keep only the top 3 sequences with the highest GC content\ntop_gc_align = derip_obj.keep_high_gc(n=3, inplace=False)\n\nprint(\n    f'After keeping the 3 sequences with the highest GC content: {len(top_gc_align)} sequences remain'\n)\n\nprint(top_gc_align)\n</pre> # Keep only the top 3 sequences with the highest GC content top_gc_align = derip_obj.keep_high_gc(n=3, inplace=False)  print(     f'After keeping the 3 sequences with the highest GC content: {len(top_gc_align)} sequences remain' )  print(top_gc_align) In\u00a0[\u00a0]: Copied! <pre># Generate a visualization of the alignment with RIP markup\nviz_file = os.path.join(output_dir, 'alignment_visualization.png')\nderip_obj.plot_alignment(\n    output_file=viz_file,\n    dpi=300,\n    title='Alignment with RIP Mutations Highlighted',\n    width=20,\n    height=15,\n    show_rip='both',  # Show both substrate and product sites\n    show_chars=True,  # Display sequence characters\n    flag_corrected=True,  # Highlight corrected positions\n)\n\n# Display the image\ndisplay(Image(viz_file))\n</pre> # Generate a visualization of the alignment with RIP markup viz_file = os.path.join(output_dir, 'alignment_visualization.png') derip_obj.plot_alignment(     output_file=viz_file,     dpi=300,     title='Alignment with RIP Mutations Highlighted',     width=20,     height=15,     show_rip='both',  # Show both substrate and product sites     show_chars=True,  # Display sequence characters     flag_corrected=True,  # Highlight corrected positions )  # Display the image display(Image(viz_file)) <p>Let's create another visualization focusing only on RIP product sites (TpA dinucleotides resulting from RIP):</p> In\u00a0[\u00a0]: Copied! <pre># Generate a visualization focusing on RIP products\nproduct_viz_file = os.path.join(output_dir, 'rip_products_visualization.png')\nderip_obj.plot_alignment(\n    output_file=product_viz_file,\n    dpi=300,\n    title='Alignment with RIP Product Sites Highlighted',\n    show_rip='product',  # Show only product sites\n    show_chars=True,\n    flag_corrected=True,\n)\n\n# Display the image\ndisplay(Image(product_viz_file))\n</pre> # Generate a visualization focusing on RIP products product_viz_file = os.path.join(output_dir, 'rip_products_visualization.png') derip_obj.plot_alignment(     output_file=product_viz_file,     dpi=300,     title='Alignment with RIP Product Sites Highlighted',     show_rip='product',  # Show only product sites     show_chars=True,     flag_corrected=True, )  # Display the image display(Image(product_viz_file)) In\u00a0[\u00a0]: Copied! <pre># Create a new DeRIP instance with reaminate=True\nderip_reaminate = DeRIP(\n    alignment_file,\n    max_snp_noise=0.2,\n    min_rip_like=0.5,\n    max_gaps=0.7,\n    reaminate=True,  # Correct all deamination events\n)\n\n# Perform RIP correction with reamination\nderip_reaminate.calculate_rip(label='deRIP_reaminate')\n\n# Write the reaminated consensus sequence\nreaminated_consensus_file = os.path.join(output_dir, 'reaminated_consensus.fasta')\nderip_reaminate.write_consensus(\n    reaminated_consensus_file, consensus_id='deRIP_reaminate'\n)\n\n# Create visualization\nreaminate_viz_file = os.path.join(output_dir, 'reaminated_visualization.png')\nderip_reaminate.plot_alignment(\n    output_file=reaminate_viz_file,\n    dpi=300,\n    title='Alignment with All Deamination Events Corrected',\n    show_rip='product',\n    show_chars=True,\n    highlight_corrected=True,\n    flag_corrected=True,\n)\n\n# Display the image\ndisplay(Image(reaminate_viz_file))\n</pre> # Create a new DeRIP instance with reaminate=True derip_reaminate = DeRIP(     alignment_file,     max_snp_noise=0.2,     min_rip_like=0.5,     max_gaps=0.7,     reaminate=True,  # Correct all deamination events )  # Perform RIP correction with reamination derip_reaminate.calculate_rip(label='deRIP_reaminate')  # Write the reaminated consensus sequence reaminated_consensus_file = os.path.join(output_dir, 'reaminated_consensus.fasta') derip_reaminate.write_consensus(     reaminated_consensus_file, consensus_id='deRIP_reaminate' )  # Create visualization reaminate_viz_file = os.path.join(output_dir, 'reaminated_visualization.png') derip_reaminate.plot_alignment(     output_file=reaminate_viz_file,     dpi=300,     title='Alignment with All Deamination Events Corrected',     show_rip='product',     show_chars=True,     highlight_corrected=True,     flag_corrected=True, )  # Display the image display(Image(reaminate_viz_file)) In\u00a0[\u00a0]: Copied! <pre># Get both consensus sequences\noriginal_consensus = derip_obj.get_consensus_string()\nreaminated_consensus = derip_reaminate.get_consensus_string()\n\n# Find differences between the sequences\ndifferences = []\nfor i, (orig, ream) in enumerate(\n    zip(original_consensus, reaminated_consensus, strict=False)\n):\n    if orig != ream:\n        differences.append((i, orig, ream))\n\n# Print comparison\nprint(f'Total differences between consensus sequences: {len(differences)}')\nprint('\\nFirst 10 differences (position, original, reaminated):')\nfor _i, (pos, orig, ream) in enumerate(differences[:10]):\n    print(f'Position {pos + 1}: {orig} \u2192 {ream}')\n</pre> # Get both consensus sequences original_consensus = derip_obj.get_consensus_string() reaminated_consensus = derip_reaminate.get_consensus_string()  # Find differences between the sequences differences = [] for i, (orig, ream) in enumerate(     zip(original_consensus, reaminated_consensus, strict=False) ):     if orig != ream:         differences.append((i, orig, ream))  # Print comparison print(f'Total differences between consensus sequences: {len(differences)}') print('\\nFirst 10 differences (position, original, reaminated):') for _i, (pos, orig, ream) in enumerate(differences[:10]):     print(f'Position {pos + 1}: {orig} \u2192 {ream}') In\u00a0[\u00a0]: Copied! <pre># Fetch the gzipped alignment file from the deRIP2 GitHub repository if running on Google Colab\nif 'google.colab' in str(get_ipython()):\n    !wget -O sahana.fasta.gz https://raw.githubusercontent.com/Adamtaranto/deRIP2/main/tests/data/sahana.fasta.gz\n    # Set the path to the gzipped alignment file\n    gzipped_alignment_file = 'sahana.fasta.gz'\nelse:\n    # Set the path to the gzipped alignment file\n    gzipped_alignment_file = '../tests/data/sahana.fasta.gz'\n</pre> # Fetch the gzipped alignment file from the deRIP2 GitHub repository if running on Google Colab if 'google.colab' in str(get_ipython()):     !wget -O sahana.fasta.gz https://raw.githubusercontent.com/Adamtaranto/deRIP2/main/tests/data/sahana.fasta.gz     # Set the path to the gzipped alignment file     gzipped_alignment_file = 'sahana.fasta.gz' else:     # Set the path to the gzipped alignment file     gzipped_alignment_file = '../tests/data/sahana.fasta.gz' In\u00a0[\u00a0]: Copied! <pre># load the gzipped file\nimport os\nfrom derip2.derip import DeRIP\n\n# Load the alignment from gzipped file\nsahana = DeRIP(gzipped_alignment_file)\n\n# Inspect alignment stats\nprint(\n    f'Alignment dimensions: {len(sahana.alignment)} sequences \u00d7 {sahana.alignment.get_alignment_length()} columns'\n)\nprint(\n    f'\\nSequence length range: {min([len(str(rec.seq).replace(\"-\", \"\")) for rec in sahana.alignment])} - {max([len(str(rec.seq).replace(\"-\", \"\")) for rec in sahana.alignment])} bp'\n)\n\n# Preview alignment\n# print(f\"\\n{sahana.alignment}\")\n</pre> # load the gzipped file import os from derip2.derip import DeRIP  # Load the alignment from gzipped file sahana = DeRIP(gzipped_alignment_file)  # Inspect alignment stats print(     f'Alignment dimensions: {len(sahana.alignment)} sequences \u00d7 {sahana.alignment.get_alignment_length()} columns' ) print(     f'\\nSequence length range: {min([len(str(rec.seq).replace(\"-\", \"\")) for rec in sahana.alignment])} - {max([len(str(rec.seq).replace(\"-\", \"\")) for rec in sahana.alignment])} bp' )  # Preview alignment # print(f\"\\n{sahana.alignment}\") In\u00a0[\u00a0]: Copied! <pre># Calc CRI\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport seaborn as sns\n\n# Calculate CRI values for all sequences\nsahana.calculate_cri_for_all()\n\n# Get CRI list\ncri_values = sahana.get_cri_values()\ncri_df = pd.DataFrame(cri_values)\n\n# Plot CRI distribution\nplt.figure(figsize=(10, 6))\nsns.histplot(cri_df['CRI'], kde=True, bins=30)\nplt.title('Distribution of CRI Values in Sahana Transposon Copies')\nplt.xlabel('Composite RIP Index (CRI)')\nplt.ylabel('Frequency')\nplt.axvline(x=1, color='red', linestyle='--', label='CRI = 1.0')\nplt.legend()\nplt.grid(alpha=0.3)\nplt.show()\n\n# Calculate GC content\ngc_values = sahana.get_gc_content()\ngc_df = pd.DataFrame(gc_values)\n\n# Plot GC content distribution\nplt.figure(figsize=(10, 6))\nsns.histplot(gc_df['GC_content'], kde=True, bins=30)\nplt.title('Distribution of GC Content in Sahana Transposon Copies')\nplt.xlabel('GC Content')\nplt.ylabel('Frequency')\nplt.grid(alpha=0.3)\nplt.show()\n\n# Summary statistics\nprint(\n    f'CRI range: {cri_df[\"CRI\"].min():.4f} - {cri_df[\"CRI\"].max():.4f}, Mean: {cri_df[\"CRI\"].mean():.4f}'\n)\nprint(\n    f'GC content range: {gc_df[\"GC_content\"].min():.4f} - {gc_df[\"GC_content\"].max():.4f}, Mean: {gc_df[\"GC_content\"].mean():.4f}'\n)\n</pre> # Calc CRI %matplotlib inline import matplotlib.pyplot as plt import pandas as pd import seaborn as sns  # Calculate CRI values for all sequences sahana.calculate_cri_for_all()  # Get CRI list cri_values = sahana.get_cri_values() cri_df = pd.DataFrame(cri_values)  # Plot CRI distribution plt.figure(figsize=(10, 6)) sns.histplot(cri_df['CRI'], kde=True, bins=30) plt.title('Distribution of CRI Values in Sahana Transposon Copies') plt.xlabel('Composite RIP Index (CRI)') plt.ylabel('Frequency') plt.axvline(x=1, color='red', linestyle='--', label='CRI = 1.0') plt.legend() plt.grid(alpha=0.3) plt.show()  # Calculate GC content gc_values = sahana.get_gc_content() gc_df = pd.DataFrame(gc_values)  # Plot GC content distribution plt.figure(figsize=(10, 6)) sns.histplot(gc_df['GC_content'], kde=True, bins=30) plt.title('Distribution of GC Content in Sahana Transposon Copies') plt.xlabel('GC Content') plt.ylabel('Frequency') plt.grid(alpha=0.3) plt.show()  # Summary statistics print(     f'CRI range: {cri_df[\"CRI\"].min():.4f} - {cri_df[\"CRI\"].max():.4f}, Mean: {cri_df[\"CRI\"].mean():.4f}' ) print(     f'GC content range: {gc_df[\"GC_content\"].min():.4f} - {gc_df[\"GC_content\"].max():.4f}, Mean: {gc_df[\"GC_content\"].mean():.4f}' ) In\u00a0[\u00a0]: Copied! <pre># Filter alignment rows that are &lt; 90% of the alignment length (not including gaps)\nfrom Bio.Align import MultipleSeqAlignment\n\n# Calculate ungapped lengths for each sequence\nungapped_lengths = [len(str(rec.seq).replace('-', '')) for rec in sahana.alignment]\nmax_ungapped_length = max(ungapped_lengths)\n\n# Set threshold at 90% of the maximum ungapped length\nlength_threshold = max_ungapped_length * 0.9\nprint(f'Maximum ungapped length: {max_ungapped_length} bp')\nprint(f'Length threshold (90%): {length_threshold:.1f} bp')\n\n# Filter sequences that meet the threshold\nfiltered_records = []\nfor rec in sahana.alignment:\n    ungapped_length = len(str(rec.seq).replace('-', ''))\n    if ungapped_length &gt;= length_threshold:\n        filtered_records.append(rec)\n\n# Create new MultipleSeqAlignment with the filtered sequences\nfiltered_alignment = MultipleSeqAlignment(filtered_records)\n\n# Update sahana's alignment with the filtered one\nsahana.alignment = filtered_alignment\n\nprint(f'Original alignment: {len(ungapped_lengths)} sequences')\nprint(f'Filtered alignment: {len(filtered_alignment)} sequences')\nprint(f'Removed: {len(ungapped_lengths) - len(filtered_alignment)} sequences')\n\n# Preview the filtered alignment\n# print(sahana)\n</pre> # Filter alignment rows that are &lt; 90% of the alignment length (not including gaps) from Bio.Align import MultipleSeqAlignment  # Calculate ungapped lengths for each sequence ungapped_lengths = [len(str(rec.seq).replace('-', '')) for rec in sahana.alignment] max_ungapped_length = max(ungapped_lengths)  # Set threshold at 90% of the maximum ungapped length length_threshold = max_ungapped_length * 0.9 print(f'Maximum ungapped length: {max_ungapped_length} bp') print(f'Length threshold (90%): {length_threshold:.1f} bp')  # Filter sequences that meet the threshold filtered_records = [] for rec in sahana.alignment:     ungapped_length = len(str(rec.seq).replace('-', ''))     if ungapped_length &gt;= length_threshold:         filtered_records.append(rec)  # Create new MultipleSeqAlignment with the filtered sequences filtered_alignment = MultipleSeqAlignment(filtered_records)  # Update sahana's alignment with the filtered one sahana.alignment = filtered_alignment  print(f'Original alignment: {len(ungapped_lengths)} sequences') print(f'Filtered alignment: {len(filtered_alignment)} sequences') print(f'Removed: {len(ungapped_lengths) - len(filtered_alignment)} sequences')  # Preview the filtered alignment # print(sahana) In\u00a0[\u00a0]: Copied! <pre># Filter for lowest 50 CRI scores\nfiltered_sahana = sahana.keep_low_cri(n=50, inplace=True)\n\n# Check new alignment dimensions\nprint(\n    f'Filtered alignment dimensions: {len(sahana.alignment)} sequences \u00d7 {sahana.alignment.get_alignment_length()} columns'\n)\n\n# Sort low to high CRI\nsahana.sort_by_cri(descending=False, inplace=True)\nprint('\\nAlignment sorted by CRI (lowest to highest)')\nprint('\\nFirst 3 sequence IDs with their CRI values:')\nfor _i, rec in enumerate(sahana.alignment[:3]):\n    print(f'{rec.id}: CRI = {rec.annotations[\"CRI\"]:.4f}')\n\n# Example on how to keep_high_gc()\n# print(\"\\nExample of keeping sequences with highest GC content:\")\n# print(f\"Before filtering: {len(sahana.alignment)} sequences\")\n# This line would be executed if you wanted to keep only high GC sequences\n# high_gc_alignment = sahana.keep_high_gc(n=50, inplace=False)\n# print(f\"After keeping top 50 high GC sequences: {len(high_gc_alignment)} sequences\")\n</pre> # Filter for lowest 50 CRI scores filtered_sahana = sahana.keep_low_cri(n=50, inplace=True)  # Check new alignment dimensions print(     f'Filtered alignment dimensions: {len(sahana.alignment)} sequences \u00d7 {sahana.alignment.get_alignment_length()} columns' )  # Sort low to high CRI sahana.sort_by_cri(descending=False, inplace=True) print('\\nAlignment sorted by CRI (lowest to highest)') print('\\nFirst 3 sequence IDs with their CRI values:') for _i, rec in enumerate(sahana.alignment[:3]):     print(f'{rec.id}: CRI = {rec.annotations[\"CRI\"]:.4f}')  # Example on how to keep_high_gc() # print(\"\\nExample of keeping sequences with highest GC content:\") # print(f\"Before filtering: {len(sahana.alignment)} sequences\") # This line would be executed if you wanted to keep only high GC sequences # high_gc_alignment = sahana.keep_high_gc(n=50, inplace=False) # print(f\"After keeping top 50 high GC sequences: {len(high_gc_alignment)} sequences\") In\u00a0[\u00a0]: Copied! <pre># Run deRIP\nsahana.calculate_rip(label='sahana_deRIP')\n\n# Information about reference sequence used for filling\nprint(f'Reference sequence used for filling: index {sahana.fill_index}')\n\n# Print summary of detected RIP mutations\nprint(sahana.rip_summary())\n</pre> # Run deRIP sahana.calculate_rip(label='sahana_deRIP')  # Information about reference sequence used for filling print(f'Reference sequence used for filling: index {sahana.fill_index}')  # Print summary of detected RIP mutations print(sahana.rip_summary()) In\u00a0[\u00a0]: Copied! <pre># Print colored alignment (first 5 sequences only, to avoid overwhelming output)\nprint('Colored alignment view (first 5 sequences):')\ncolored_lines = sahana.colored_alignment.split('\\n')\nfor line in colored_lines[:5]:\n    print(line)\nprint('...')\n\n# Normal and colored consensus\nprint('\\nConsensus sequence (first 100 bp):')\nprint(sahana.get_consensus_string()[:100] + '...')\n\nprint('\\nColored consensus sequence:')\nprint(sahana.colored_consensus)\n\n# Report on remaining variable positions that were filled from reference\nprint(f'\\nTotal positions corrected during deRIP: {len(sahana.corrected_positions)}')\n</pre> # Print colored alignment (first 5 sequences only, to avoid overwhelming output) print('Colored alignment view (first 5 sequences):') colored_lines = sahana.colored_alignment.split('\\n') for line in colored_lines[:5]:     print(line) print('...')  # Normal and colored consensus print('\\nConsensus sequence (first 100 bp):') print(sahana.get_consensus_string()[:100] + '...')  print('\\nColored consensus sequence:') print(sahana.colored_consensus)  # Report on remaining variable positions that were filled from reference print(f'\\nTotal positions corrected during deRIP: {len(sahana.corrected_positions)}') In\u00a0[\u00a0]: Copied! <pre># Create an output directory if it doesn't exist\noutput_dir = 'sahana_output'\nos.makedirs(output_dir, exist_ok=True)\n\n# Write the ungapped consensus sequence\nconsensus_file = os.path.join(output_dir, 'sahana_derip_consensus.fasta')\nsahana.write_consensus(consensus_file, consensus_id='sahana_deRIP')\n\n# Write the alignment with consensus appended\nalignment_file = os.path.join(output_dir, 'sahana_alignment_with_consensus.fasta')\nsahana.write_alignment(\n    output_file=alignment_file,\n    append_consensus=True,\n    mask_rip=False,  # Original sequences, not masked\n    consensus_id='sahana_deRIP',\n)\n\n# Write the masked alignment with consensus appended\nmasked_alignment_file = os.path.join(\n    output_dir, 'sahana_masked_alignment_with_consensus.fasta'\n)\nsahana.write_alignment(\n    output_file=masked_alignment_file,\n    append_consensus=True,\n    mask_rip=True,  # Masked sequences\n    consensus_id='sahana_deRIP',\n)\n\nprint(f'Files written to {output_dir}:')\nprint(f'  - {os.path.basename(consensus_file)}')\nprint(f'  - {os.path.basename(alignment_file)}')\nprint(f'  - {os.path.basename(masked_alignment_file)}')\n</pre> # Create an output directory if it doesn't exist output_dir = 'sahana_output' os.makedirs(output_dir, exist_ok=True)  # Write the ungapped consensus sequence consensus_file = os.path.join(output_dir, 'sahana_derip_consensus.fasta') sahana.write_consensus(consensus_file, consensus_id='sahana_deRIP')  # Write the alignment with consensus appended alignment_file = os.path.join(output_dir, 'sahana_alignment_with_consensus.fasta') sahana.write_alignment(     output_file=alignment_file,     append_consensus=True,     mask_rip=False,  # Original sequences, not masked     consensus_id='sahana_deRIP', )  # Write the masked alignment with consensus appended masked_alignment_file = os.path.join(     output_dir, 'sahana_masked_alignment_with_consensus.fasta' ) sahana.write_alignment(     output_file=masked_alignment_file,     append_consensus=True,     mask_rip=True,  # Masked sequences     consensus_id='sahana_deRIP', )  print(f'Files written to {output_dir}:') print(f'  - {os.path.basename(consensus_file)}') print(f'  - {os.path.basename(alignment_file)}') print(f'  - {os.path.basename(masked_alignment_file)}') In\u00a0[\u00a0]: Copied! <pre># Create a plot of the alignment\nplot_file = os.path.join(output_dir, 'sahana_alignment_visualization.png')\n\nsahana.plot_alignment(\n    output_file=plot_file,\n    dpi=300,\n    title='Sahana Transposon Alignment with RIP Corrections',\n    width=20,\n    height=12,\n    show_chars=False,  # Off for large alignments\n    draw_boxes=False,  # Off for large alignments\n    show_rip='product',  # Show RIP product only\n    highlight_corrected=True,  # Highlight corrected positions\n    flag_corrected=False,  # Off for large alignments\n)\n\nprint(f'Plot saved to {plot_file}')\n\n# Note: Variables that can customize the plot:\n# - show_rip: Options are 'product', 'substrate', or 'both'\n# - highlight_corrected: Whether to highlight corrected positions in consensus\n# - flag_corrected: Whether to mark corrected positions with asterisks\n\n# Display the generated plot\ndisplay(Image(plot_file))\n</pre> # Create a plot of the alignment plot_file = os.path.join(output_dir, 'sahana_alignment_visualization.png')  sahana.plot_alignment(     output_file=plot_file,     dpi=300,     title='Sahana Transposon Alignment with RIP Corrections',     width=20,     height=12,     show_chars=False,  # Off for large alignments     draw_boxes=False,  # Off for large alignments     show_rip='product',  # Show RIP product only     highlight_corrected=True,  # Highlight corrected positions     flag_corrected=False,  # Off for large alignments )  print(f'Plot saved to {plot_file}')  # Note: Variables that can customize the plot: # - show_rip: Options are 'product', 'substrate', or 'both' # - highlight_corrected: Whether to highlight corrected positions in consensus # - flag_corrected: Whether to mark corrected positions with asterisks  # Display the generated plot display(Image(plot_file))"},{"location":"tutorial/#derip2-tutorial-using-the-derip-class-directly","title":"deRIP2 Tutorial: Using the DeRIP Class Directly\u00b6","text":"<p>This tutorial demonstrates how to use the <code>DeRIP</code> class from the <code>derip2</code> package directly in Python, without using the command-line interface. This gives you more programmatic control and flexibility when working with RIP analysis and correction.</p>"},{"location":"tutorial/#1-introduction","title":"1. Introduction\u00b6","text":"<p>deRIP2 is a tool for detecting and correcting RIP (Repeat-Induced Point) mutations in fungal DNA alignments. RIP is a genome defense mechanism that introduces C\u2192T mutations (and the complementary G\u2192A on the opposite strand) in specific sequence contexts.</p> <p>Key features of deRIP2:</p> <ul> <li>Predicts ancestral fungal transposon sequences by correcting for RIP-like mutations</li> <li>Masks RIP or deamination events as ambiguous bases</li> <li>Provides tools for analyzing RIP patterns and dinucleotide frequencies</li> <li>Calculates Composite RIP Index (CRI) and other metrics</li> <li>Offers visualization of alignments with RIP annotations</li> </ul>"},{"location":"tutorial/#2-installation-and-setup","title":"2. Installation and Setup\u00b6","text":"<p>If you haven't installed deRIP2 yet, you can do so via pip:</p>"},{"location":"tutorial/#3-loading-and-examining-an-alignment","title":"3. Loading and Examining an Alignment\u00b6","text":"<p>First, let's load a multiple sequence alignment file. For this tutorial, we'll use the example file included with deRIP2.</p>"},{"location":"tutorial/#4-basic-rip-analysis-and-correction","title":"4. Basic RIP Analysis and Correction\u00b6","text":"<p>Now let's perform RIP detection and correction on the alignment. This is the core functionality of deRIP2.</p>"},{"location":"tutorial/#examining-the-corrected-consensus-sequence","title":"Examining the Corrected Consensus Sequence\u00b6","text":"<p>After running <code>calculate_rip()</code>, we can examine the corrected consensus sequence and see how it compares to the original sequences.</p>"},{"location":"tutorial/#5-working-with-composite-rip-index-cri","title":"5. Working with Composite RIP Index (CRI)\u00b6","text":"<p>The Composite RIP Index (CRI) is a metric for measuring the extent of RIP mutations in a sequence. It combines two indices:</p> <ul> <li>Product Index (PI) = TpA / ApT</li> <li>Substrate Index (SI) = (CpA + TpG) / (ApC + GpT)</li> <li>CRI = PI - SI</li> </ul> <p>A high CRI value indicates strong RIP activity. Let's analyze CRI values for our sequences.</p>"},{"location":"tutorial/#sorting-and-filtering-by-cri","title":"Sorting and Filtering by CRI\u00b6","text":"<p>We can sort sequences by their CRI values using <code>sort_by_cri()</code>. This can help identify sequences with the highest or lowest RIP activity.</p> <p>By default <code>sort_by_cri()</code> returns a new <code>Bio.Align.Bio.MultipleSeqAlignment</code> object. If you want to modify the original alignment in place, you can set <code>inplace=True</code>.</p>"},{"location":"tutorial/#6-gc-content-analysis","title":"6. GC Content Analysis\u00b6","text":"<p>RIP mutations typically reduce GC content by converting C to T. Let's analyze the GC content distribution in our sequences:</p>"},{"location":"tutorial/#filtering-by-gc-content","title":"Filtering by GC Content\u00b6","text":"<p>We can filter sequences based on their GC content:</p>"},{"location":"tutorial/#7-visualizing-alignments","title":"7. Visualizing Alignments\u00b6","text":"<p>deRIP2 offers visualization capabilities to see the alignment with RIP sites highlighted. This is particularly useful for understanding where RIP corrections have been made.</p>"},{"location":"tutorial/#8-re-running-with-different-parameters","title":"8. Re-running with Different Parameters\u00b6","text":"<p>Let's demonstrate how to re-run the analysis with different parameters, such as enabling the <code>reaminate</code> option to correct all deamination events regardless of RIP context:</p>"},{"location":"tutorial/#9-comparing-original-and-reaminated-consensus-sequences","title":"9. Comparing Original and Reaminated Consensus Sequences\u00b6","text":"<p>Let's compare the consensus sequences from both approaches to see how the <code>reaminate</code> option affects the results:</p>"},{"location":"tutorial/#10-working-with-a-real-transposon-alignment","title":"10. Working with a real transposon alignment\u00b6","text":"<p>In this section we will process a large alignment containing 396 copies of the DNA transposon Sahana from Leptosphaeria maculans.</p> <p>Most copies are heavily RIP'd and some are fragmented. This aligment has been pre-curated with TEtrimmer to remove poorly aligned regions that might interfere with RIP detection.</p>"},{"location":"tutorial/#loading-the-alignment","title":"Loading the alignment\u00b6","text":""},{"location":"tutorial/#inspecting-sequence-properties","title":"Inspecting sequence properties\u00b6","text":"<p>Next we will calculate the Composite RIP Index (CRI) and GC scores and inspect their distributions.</p>"},{"location":"tutorial/#filtering-the-alignment","title":"Filtering the alignment\u00b6","text":"<p>Generally it is best to include all available sequences in your DeRIP analysis to maximise discovery of un-mutated substrate motifs that can be used for sequence correction.</p> <p>However, large alignments can take a long time to process.</p> <p>Consider the following methods to reduce your alignment size:</p> <ul> <li>Filter out sequences with high CRI scores or low GC proportions</li> <li>Remove duplicate sequences</li> <li>Remove partial sequences</li> </ul>"},{"location":"tutorial/#removing-partial-sequences","title":"Removing partial sequences\u00b6","text":"<p>First we will remove partial sequences that are less than 90% the length of the consensus sequence.</p> <p>We can directly edit the <code>sahana.aligntment</code> attribute to remove these sequences.</p>"},{"location":"tutorial/#keep-only-the-best-50-sequences-by-cri","title":"Keep only the best 50 sequences by CRI\u00b6","text":"<p>Low CRI scores are indicative of fewer RIP mutations. We will keep only the best 50 sequences by CRI score.</p> <p>We can use the <code>keep_low_cri()</code> method with <code>inplace=True</code> to filter the alignment attribute.</p>"},{"location":"tutorial/#calculating-rip-motifs-and-consensus","title":"Calculating RIP motifs and consensus\u00b6","text":"<p>Now we will run <code>calculate_rip()</code> to identify RIP substrate and product motifs, and to calculate the deRIP'd consensus.</p>"},{"location":"tutorial/#inspect-calculated-rip-features","title":"Inspect calculated RIP features\u00b6","text":"<p>Lets inspect the object. Several new attributes are now available.</p>"},{"location":"tutorial/#writing-the-results-to-file","title":"Writing the results to file\u00b6","text":"<p>We can write the ungapped consensus, alignment +/- consensus, or masked alignment +/- consensus to fasta file.</p>"},{"location":"tutorial/#plotting-processed-alignment","title":"Plotting processed alignment\u00b6","text":""},{"location":"tutorial/#conclusion","title":"Conclusion\u00b6","text":"<p>This tutorial demonstrates how to use the <code>DeRIP</code> class directly for programmatic analysis of RIP mutations in DNA alignments. The class-based approach offers more flexibility and integration possibilities compared to the command-line interface.</p> <p>Key functionalities covered:</p> <ul> <li>Loading and examining alignments</li> <li>RIP detection and correction</li> <li>CRI calculation and sequence filtering</li> <li>GC content analysis</li> <li>Alignment visualization</li> <li>Comparing different parameter settings</li> </ul> <p>For more information and advanced usage, refer to the deRIP2 GitHub repository.</p>"},{"location":"api-docs/deRIP_API/","title":"DeRIP Class","text":""},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP","title":"DeRIP","text":"<pre><code>DeRIP(\n    alignment_input,\n    max_snp_noise: float = 0.5,\n    min_rip_like: float = 0.1,\n    reaminate: bool = False,\n    fill_index: Optional[int] = None,\n    fill_max_gc: bool = False,\n    max_gaps: float = 0.7,\n)\n</code></pre> <p>A class to detect and correct RIP (Repeat-Induced Point) mutations in DNA alignments.</p> <p>This class encapsulates the functionality to analyze DNA sequence alignments for RIP-like mutations, correct them, and generate deRIPed consensus sequences.</p> PARAMETER DESCRIPTION <code>alignment_input</code> <p>Path to the alignment file in FASTA format or a pre-loaded MultipleSeqAlignment object.</p> <p> TYPE: <code>str or MultipleSeqAlignment</code> </p> <code>max_snp_noise</code> <p>Maximum proportion of conflicting SNPs permitted before excluding column from RIP/deamination assessment (default: 0.5).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>min_rip_like</code> <p>Minimum proportion of deamination events in RIP context required for column to be deRIP'd in final sequence (default: 0.1).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>reaminate</code> <p>Whether to correct all deamination events independent of RIP context (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>fill_index</code> <p>Index of row to use for filling uncorrected positions (default: None).</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>fill_max_gc</code> <p>Whether to use sequence with highest GC content for filling if no row index is specified (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>max_gaps</code> <p>Maximum proportion of gaps in a column before considering it a gap in consensus (default: 0.7).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.7</code> </p> ATTRIBUTE DESCRIPTION <code>alignment</code> <p>The loaded DNA sequence alignment.</p> <p> TYPE: <code>MultipleSeqAlignment</code> </p> <code>masked_alignment</code> <p>The alignment with RIP-corrected positions masked with IUPAC codes.</p> <p> TYPE: <code>MultipleSeqAlignment</code> </p> <code>consensus</code> <p>The deRIPed consensus sequence.</p> <p> TYPE: <code>SeqRecord</code> </p> <code>gapped_consensus</code> <p>The deRIPed consensus sequence with gaps.</p> <p> TYPE: <code>SeqRecord</code> </p> <code>rip_counts</code> <p>Dictionary tracking RIP mutation counts for each sequence.</p> <p> TYPE: <code>Dict</code> </p> <code>corrected_positions</code> <p>Dictionary of corrected positions {col_idx: {row_idx: {observed_base, corrected_base}}}.</p> <p> TYPE: <code>Dict</code> </p> <code>colored_consensus</code> <p>Consensus sequence with corrected positions highlighted in green.</p> <p> TYPE: <code>str</code> </p> <code>colored_alignment</code> <p>Alignment with corrected positions highlighted in green.</p> <p> TYPE: <code>str</code> </p> <code>colored_masked_alignment</code> <p>Masked alignment with RIP positions highlighted in color.</p> <p> TYPE: <code>str</code> </p> <code>markupdict</code> <p>Dictionary of markup codes for masked positions.</p> <p> TYPE: <code>Dict</code> </p> <p>Initialize DeRIP with an alignment file or MultipleSeqAlignment object and parameters.</p> PARAMETER DESCRIPTION <code>alignment_input</code> <p>Path to the alignment file in FASTA format or a pre-loaded MultipleSeqAlignment object. If a MultipleSeqAlignment is provided, it must contain at least 2 sequences.</p> <p> TYPE: <code>str or MultipleSeqAlignment</code> </p> <code>max_snp_noise</code> <p>Maximum proportion of conflicting SNPs permitted before excluding column from RIP/deamination assessment (default: 0.5).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>min_rip_like</code> <p>Minimum proportion of deamination events in RIP context required for column to be deRIP'd in final sequence (default: 0.1).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>reaminate</code> <p>Whether to correct all deamination events independent of RIP context (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>fill_index</code> <p>Index of row to use for filling uncorrected positions (default: None).</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>fill_max_gc</code> <p>Whether to use sequence with highest GC content for filling if no row index is specified (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>max_gaps</code> <p>Maximum proportion of gaps in a column before considering it a gap in consensus (default: 0.7).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.7</code> </p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.calculate_rip","title":"calculate_rip","text":"<pre><code>calculate_rip(label: str = 'deRIPseq') -&gt; None\n</code></pre> <p>Calculate RIP locations and corrections in the alignment.</p> <p>This method performs RIP detection and correction, fills in the consensus sequence, and populates the class attributes.</p> PARAMETER DESCRIPTION <code>label</code> <p>ID for the generated deRIPed sequence (default: \"deRIPseq\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'deRIPseq'</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Updates class attributes with results.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.calculate_cri","title":"calculate_cri","text":"<pre><code>calculate_cri(sequence)\n</code></pre> <p>Calculate the Composite RIP Index (CRI) for a DNA sequence.</p> PARAMETER DESCRIPTION <code>sequence</code> <p>The DNA sequence to analyze.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>(cri, pi, si) - Composite RIP Index, Product Index, and Substrate Index.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.calculate_cri_for_all","title":"calculate_cri_for_all","text":"<pre><code>calculate_cri_for_all()\n</code></pre> <p>Calculate the Composite RIP Index (CRI) for each sequence in the alignment and assign CRI values as annotations to each sequence record.</p> RETURNS DESCRIPTION <code>MultipleSeqAlignment</code> <p>The alignment with CRI metadata added to each record.</p> Notes <p>This method calculates: - Product Index (PI) = TpA / ApT - Substrate Index (SI) = (CpA + TpG) / (ApC + GpT) - Composite RIP Index (CRI) = PI - SI</p> <p>High CRI values indicate strong RIP activity.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.calculate_dinucleotide_frequency","title":"calculate_dinucleotide_frequency","text":"<pre><code>calculate_dinucleotide_frequency(sequence)\n</code></pre> <p>Calculate the frequency of specific dinucleotides in a sequence.</p> PARAMETER DESCRIPTION <code>sequence</code> <p>The DNA sequence to analyze.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary with dinucleotide counts.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.rip_summary","title":"rip_summary","text":"<pre><code>rip_summary() -&gt; None\n</code></pre> <p>Return a summary of RIP mutations found in each sequence as str.</p> RETURNS DESCRIPTION <code>str</code> <p>Summary of RIP mutations by sequence.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If calculate_rip has not been called first.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.summarize_cri","title":"summarize_cri","text":"<pre><code>summarize_cri()\n</code></pre> <p>Generate a formatted table summarizing CRI values for all sequences.</p> RETURNS DESCRIPTION <code>str</code> <p>A formatted string containing the CRI summary table.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.write_alignment","title":"write_alignment","text":"<pre><code>write_alignment(\n    output_file: str,\n    append_consensus: bool = True,\n    mask_rip: bool = True,\n    consensus_id: str = 'deRIPseq',\n    format: str = 'fasta',\n) -&gt; None\n</code></pre> <p>Write alignment to file with options to append consensus and mask RIP positions.</p> PARAMETER DESCRIPTION <code>output_file</code> <p>Path to the output alignment file.</p> <p> TYPE: <code>str</code> </p> <code>append_consensus</code> <p>Whether to append the consensus sequence to the alignment (default: True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>mask_rip</code> <p>Whether to mask RIP positions in the output alignment (default: True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>consensus_id</code> <p>ID for the consensus sequence if appended (default: \"deRIPseq\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'deRIPseq'</code> </p> <code>format</code> <p>Format for the output alignment file (default: \"fasta\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fasta'</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Writes alignment to file.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If calculate_rip has not been called first.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.write_consensus","title":"write_consensus","text":"<pre><code>write_consensus(output_file: str, consensus_id: str = 'deRIPseq') -&gt; None\n</code></pre> <p>Write the deRIPed consensus sequence to a FASTA file.</p> PARAMETER DESCRIPTION <code>output_file</code> <p>Path to the output FASTA file.</p> <p> TYPE: <code>str</code> </p> <code>consensus_id</code> <p>ID for the consensus sequence (default: \"deRIPseq\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'deRIPseq'</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Writes consensus sequence to file.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If calculate_rip has not been called first.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.plot_alignment","title":"plot_alignment","text":"<pre><code>plot_alignment(\n    output_file: str,\n    dpi: int = 300,\n    title: Optional[str] = None,\n    width: int = 20,\n    height: int = 15,\n    palette: str = 'derip2',\n    column_ranges: Optional[List[Tuple[int, int, str, str]]] = None,\n    show_chars: bool = False,\n    draw_boxes: bool = False,\n    show_rip: str = 'both',\n    highlight_corrected: bool = True,\n    flag_corrected: bool = False,\n    **kwargs,\n) -&gt; str\n</code></pre> <p>Generate a visualization of the alignment with RIP mutations highlighted.</p> <p>This method creates a PNG image showing the aligned sequences with color-coded highlighting of RIP mutations and corrections. It displays the consensus sequence below the alignment with asterisks marking corrected positions.</p> PARAMETER DESCRIPTION <code>output_file</code> <p>Path to save the output image file.</p> <p> TYPE: <code>str</code> </p> <code>dpi</code> <p>Resolution of the output image in dots per inch (default: 300).</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p> <code>title</code> <p>Title to display on the image (default: None).</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>width</code> <p>Width of the output image in inches (default: 20).</p> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> <code>height</code> <p>Height of the output image in inches (default: 15).</p> <p> TYPE: <code>int</code> DEFAULT: <code>15</code> </p> <code>palette</code> <p>Color palette to use: 'colorblind', 'bright', 'tetrimmer', 'basegrey', or 'derip2' (default: 'basegrey').</p> <p> TYPE: <code>str</code> DEFAULT: <code>'derip2'</code> </p> <code>column_ranges</code> <p>List of column ranges to mark, each as (start_col, end_col, color, label) (default: None).</p> <p> TYPE: <code>List[Tuple[int, int, str, str]]</code> DEFAULT: <code>None</code> </p> <code>show_chars</code> <p>Whether to display sequence characters inside the colored cells (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>draw_boxes</code> <p>Whether to draw black borders around highlighted bases (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>show_rip</code> <p>Which RIP markup categories to include: 'substrate', 'product', or 'both' (default: 'both').</p> <p> TYPE: <code>str</code> DEFAULT: <code>'both'</code> </p> <code>highlight_corrected</code> <p>If True, only corrected positions in the consensus will be colored, all others will be gray (default: True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>flag_corrected</code> <p>If True, corrected positions in the alignment will be marked with asterisks (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to drawMiniAlignment function.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Path to the output image file.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If calculate_rip has not been called first.</p> Notes <p>The visualization uses different colors to distinguish RIP-related mutations: - Red: RIP products (typically T from C\u2192T mutations) - Blue: RIP substrates (unmutated nucleotides in RIP context) - Yellow: Non-RIP deaminations (only if reaminate=True) - Target bases are displayed in black text, while surrounding context is in grey text</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.get_cri_values","title":"get_cri_values","text":"<pre><code>get_cri_values()\n</code></pre> <p>Return a list of CRI values for all sequences in the alignment.</p> <p>If a sequence doesn't have a CRI value yet, calculate it first.</p> RETURNS DESCRIPTION <code>list of dict</code> <p>List of dictionaries containing CRI, PI, SI values and sequence ID, in the same order as sequences appear in the alignment.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.get_gc_content","title":"get_gc_content","text":"<pre><code>get_gc_content()\n</code></pre> <p>Calculate and return the GC content for all sequences in the alignment.</p> RETURNS DESCRIPTION <code>list of dict</code> <p>List of dictionaries containing sequence ID and GC content, in the same order as sequences appear in the alignment.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no alignment is loaded.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.get_consensus_string","title":"get_consensus_string","text":"<pre><code>get_consensus_string() -&gt; str\n</code></pre> <p>Get the deRIPed consensus sequence as a string.</p> RETURNS DESCRIPTION <code>str</code> <p>The deRIPed consensus sequence.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If calculate_rip has not been called first.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.sort_by_cri","title":"sort_by_cri","text":"<pre><code>sort_by_cri(descending=True, inplace=False)\n</code></pre> <p>Sort the alignment by CRI score.</p> PARAMETER DESCRIPTION <code>descending</code> <p>If True, sort in descending order (highest CRI first). Default: True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>If True, replace the current alignment with the sorted alignment. If False, return a new alignment without modifying the original (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>MultipleSeqAlignment</code> <p>A new alignment with sequences sorted by CRI score.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.filter_by_cri","title":"filter_by_cri","text":"<pre><code>filter_by_cri(min_cri=0.0, inplace=False)\n</code></pre> <p>Filter the alignment to remove sequences with CRI values below a threshold.</p> PARAMETER DESCRIPTION <code>min_cri</code> <p>Minimum CRI value to keep a sequence in the alignment (default: 0.0).</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>inplace</code> <p>If True, replace the current alignment with the filtered alignment. If False, return a new alignment without modifying the original (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>MultipleSeqAlignment</code> <p>A new alignment containing only sequences with CRI values &gt;= min_cri.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no alignment is loaded or if filtering would remove all sequences.</p> <code>Warning</code> <p>If fewer than 2 sequences remain after filtering.</p> Notes <p>CRI values will be calculated for sequences that don't already have them. If inplace=True, this will modify the original alignment in the DeRIP object.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.filter_by_gc","title":"filter_by_gc","text":"<pre><code>filter_by_gc(min_gc=0.0, inplace=False)\n</code></pre> <p>Filter the alignment to remove sequences with GC content below a threshold.</p> PARAMETER DESCRIPTION <code>min_gc</code> <p>Minimum GC content to keep a sequence in the alignment (default: 0.0). Value should be between 0.0 and 1.0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>inplace</code> <p>If True, replace the current alignment with the filtered alignment. If False, return a new alignment without modifying the original (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>MultipleSeqAlignment</code> <p>A new alignment containing only sequences with GC content &gt;= min_gc.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no alignment is loaded or if filtering would remove all sequences.</p> <code>Warning</code> <p>If fewer than 2 sequences remain after filtering.</p> Notes <p>GC content will be calculated for sequences that don't already have it. If inplace=True, this will modify the original alignment in the DeRIP object.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.keep_low_cri","title":"keep_low_cri","text":"<pre><code>keep_low_cri(n=2, inplace=False)\n</code></pre> <p>Retain only the n sequences with the lowest CRI values.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of sequences with lowest CRI values to keep (default: 2).</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>inplace</code> <p>If True, replace the current alignment with the filtered alignment. If False, return a new alignment without modifying the original (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>MultipleSeqAlignment</code> <p>A new alignment containing only the n sequences with lowest CRI values.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no alignment is loaded.</p> Notes <p>CRI values will be calculated for sequences that don't already have them. If inplace=True, this will modify the original alignment in the DeRIP object. If n is greater than the number of sequences, no filtering occurs. If n is less than 2, no filtering occurs to ensure DeRIP has enough sequences to work with.</p>"},{"location":"api-docs/deRIP_API/#derip2.derip.DeRIP.keep_high_gc","title":"keep_high_gc","text":"<pre><code>keep_high_gc(n=2, inplace=False)\n</code></pre> <p>Retain only the n sequences with the highest GC content.</p> PARAMETER DESCRIPTION <code>n</code> <p>Number of sequences with highest GC content to keep (default: 2).</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>inplace</code> <p>If True, replace the current alignment with the filtered alignment. If False, return a new alignment without modifying the original (default: False).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>MultipleSeqAlignment</code> <p>A new alignment containing only the n sequences with highest GC content.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no alignment is loaded.</p> Notes <p>GC content will be calculated for sequences that don't already have it. If inplace=True, this will modify the original alignment in the DeRIP object. If n is greater than the number of sequences, no filtering occurs. If n is less than 2, no filtering occurs to ensure DeRIP has enough sequences to work with.</p>"},{"location":"cli-docs/deRIP_cmd_line/","title":"DeRIP2 Command Line Interface","text":""},{"location":"cli-docs/deRIP_cmd_line/#basic-usage","title":"Basic usage","text":"<p>For aligned sequences in 'mintest.fa':</p> <ul> <li>Any column with &gt;= 70% gap positions will not be corrected and a gap inserted in corrected sequence.</li> <li>Bases in column must be &gt;= 80% C/T or G/A</li> <li>At least 50% bases in a column must be in RIP dinucleotide context (C/T as CpA / TpA) for correction.</li> <li>Default: Inherit all remaining uncorrected positions from the least RIP'd sequence.</li> <li>Mask all substrate and product motifs from corrected columns as ambiguous bases (i.e. CpA to TpA --&gt; YpA)</li> </ul>"},{"location":"cli-docs/deRIP_cmd_line/#basic-usage-with-masking","title":"Basic usage with masking","text":"<pre><code>derip2 -i tests/data/mintest.fa \\\n  --max-gaps 0.7 \\\n  --max-snp-noise 0.2 \\\n  --min-rip-like 0.5 \\\n  --mask \\\n  -d results \\\n  --prefix derip_output\n</code></pre> <p>Output:</p> <ul> <li><code>results/derip_output.fasta</code> - Corrected sequence</li> <li><code>results/derip_output_alignment.fasta</code> - Alignment with masked corrections</li> <li><code>results/derip_output_masked_alignment.fasta</code> - Alignment with masked corrections</li> </ul>"},{"location":"cli-docs/deRIP_cmd_line/#with-vizualization","title":"With vizualization","text":"<p>The <code>--plot</code> option will create a visualization of the alignment with RIP markup. The <code>--plot-rip-type</code> option can be used to specify the type of RIP events to be displayed in the alignment visualization <code>product</code>, <code>substrate</code>, or <code>both</code>.</p> <pre><code>derip2 -i tests/data/mintest.fa \\\n  --max-gaps 0.7 \\\n  --max-snp-noise 0.2 \\\n  --min-rip-like 0.5 \\\n  --plot \\\n  --plot-rip-type both \\\n  -d results \\\n  --prefix derip_output\n</code></pre> <p>Output:</p> <ul> <li><code>results/derip_output.fasta</code> - Corrected sequence</li> <li><code>results/derip_output_masked_alignment.fasta</code> - Alignment with masked corrections</li> <li><code>results/derip_output_visualization.png</code> - Visualization of the alignment with RIP markup</li> </ul> <p></p>"},{"location":"cli-docs/deRIP_cmd_line/#using-maximum-gc-content-for-filling","title":"Using maximum GC content for filling","text":"<p>By default uncorrected positions in the output sequence are filled from the sequence with the lowest RIP count. If the <code>--fill-max-gc</code> option is set, remaining positions are filled from the sequence with the highest G/C content sequence instead.</p> <pre><code>derip2 -i tests/data/mintest.fa \\\n  --max-gaps 0.7 \\\n  --max-snp-noise 0.2 \\\n  --min-rip-like 0.5 \\\n  --fill-max-gc \\\n  -d results \\\n  --prefix derip_gc_filled\n</code></pre> <p>Alternatively, the <code>--fill-index</code> option can be used to force selection of alignment row to fill uncorrected positions from by row index number (indexed from 0). Note: This will override the <code>--fill-max-gc</code> option.</p>"},{"location":"cli-docs/deRIP_cmd_line/#correcting-all-deamination-events","title":"Correcting all deamination events","text":"<p>If the <code>--reaminate</code> option is set, all deamination events will be corrected, regardless of RIP context.</p> <p><code>--plot-rip-type product</code> is used to highlight the product of RIP events in the visualization. Non-RIP deamination events are also highlighted.</p> <pre><code>derip2 -i tests/data/mintest.fa \\\n  --max-gaps 0.7 \\\n  --reaminate \\\n  -d results \\\n  --plot \\\n  --plot-rip-type product \\\n  --prefix derip_reaminated\n</code></pre> <p>Output:</p> <ul> <li><code>results/derip_reaminated.fasta</code> - Corrected sequence using highest GC content sequence for filling</li> <li><code>results/derip_reaminated_alignment.fasta</code> - Alignment with corrected sequence appended</li> <li><code>results/derip_reaminated_vizualization.png</code> - Visualization of the alignment with RIP markup</li> </ul> <p></p>"},{"location":"cli-docs/deRIP_cmd_line/#standard-options","title":"Standard Options","text":"<pre><code>  --version                       Show the version and exit.\n  -i, --input TEXT                Multiple sequence alignment.  [required]\n  -g, --max-gaps FLOAT            Maximum proportion of gapped positions in\n                                  column to be tolerated before forcing a gap\n                                  in final deRIP sequence.  [default: 0.7]\n  -a, --reaminate                 Correct all deamination events independent\n                                  of RIP context.\n  --max-snp-noise FLOAT           Maximum proportion of conflicting SNPs\n                                  permitted before excluding column from\n                                  RIP/deamination assessment. i.e. By default\n                                  a column with &gt;= 0.5 'C/T' bases will have\n                                  'TpA' positions logged as RIP events.\n                                  [default: 0.5]\n  --min-rip-like FLOAT            Minimum proportion of deamination events in\n                                  RIP context (5' CpA 3' --&gt; 5' TpA 3')\n                                  required for column to deRIP'd in final\n                                  sequence. Note: If 'reaminate' option is set\n                                  all deamination events will be corrected.\n                                  [default: 0.1]\n  --fill-max-gc                   By default uncorrected positions in the\n                                  output sequence are filled from the sequence\n                                  with the lowest RIP count. If this option is\n                                  set remaining positions are filled from the\n                                  sequence with the highest G/C content.\n  --fill-index INTEGER            Force selection of alignment row to fill\n                                  uncorrected positions from by row index\n                                  number (indexed from 0). Note: Will override\n                                  '--fill-max-gc' option.\n  --mask                          Mask corrected positions in alignment with\n                                  degenerate IUPAC codes.\n  --no-append                     If set, do not append deRIP'd sequence to\n                                  output alignment.\n  -d, --out-dir TEXT              Directory for deRIP'd sequence files to be\n                                  written to.\n  -p, --prefix TEXT               Prefix for output files. Output files will\n                                  be named prefix.fasta,\n                                  prefix_alignment.fasta, etc.  [default:\n                                  deRIPseq]\n  --plot                          Create a visualization of the alignment with\n                                  RIP markup.\n  --plot-rip-type [both|product|substrate]\n                                  Specify the type of RIP events to be\n                                  displayed in the alignment visualization.\n                                  [default: both]\n  --loglevel [DEBUG|INFO|WARNING|ERROR|CRITICAL]\n                                  Set logging level.  [default: INFO]\n  --logfile TEXT                  Log file path.\n  -h, --help                      Show this message and exit.\n</code></pre>"}]}